import { CodeError } from '@libp2p/interface/errors';
import { EventEmitter } from '@libp2p/interface/events';
import { logger } from '@libp2p/logger';
import { PeerMap } from '@libp2p/peer-collections';
import { peerIdFromString } from '@libp2p/peer-id';
import { multiaddr } from '@multiformats/multiaddr';
const log = logger('libp2p:circuit-relay:transport:listener');
class CircuitRelayTransportListener extends EventEmitter {
    connectionManager;
    relayStore;
    listeningAddrs;
    constructor(components) {
        super();
        this.connectionManager = components.connectionManager;
        this.relayStore = components.relayStore;
        this.listeningAddrs = new PeerMap();
        // remove listening addrs when a relay is removed
        this.relayStore.addEventListener('relay:removed', (evt) => {
            this.#removeRelayPeer(evt.detail);
        });
    }
    async listen(addr) {
        log('listen on %a', addr);
        const relayPeerStr = addr.getPeerId();
        let relayConn;
        // check if we already have a connection to the relay
        if (relayPeerStr != null) {
            const relayPeer = peerIdFromString(relayPeerStr);
            const connections = this.connectionManager.getConnectionsMap().get(relayPeer) ?? [];
            if (connections.length > 0) {
                relayConn = connections[0];
            }
        }
        // open a new connection as we don't already have one
        if (relayConn == null) {
            const addrString = addr.toString().split('/p2p-circuit').find(a => a !== '');
            const ma = multiaddr(addrString);
            relayConn = await this.connectionManager.openConnection(ma);
        }
        if (!this.relayStore.hasReservation(relayConn.remotePeer)) {
            // addRelay calls transportManager.listen which calls this listen method
            await this.relayStore.addRelay(relayConn.remotePeer, 'configured');
            return;
        }
        const reservation = this.relayStore.getReservation(relayConn.remotePeer);
        if (reservation == null) {
            throw new CodeError('Did not have reservation after making reservation', 'ERR_NO_RESERVATION');
        }
        if (this.listeningAddrs.has(relayConn.remotePeer)) {
            log('already listening on relay %p', relayConn.remotePeer);
            return;
        }
        // add all addresses from the relay reservation
        this.listeningAddrs.set(relayConn.remotePeer, reservation.addrs.map(buf => {
            return multiaddr(buf).encapsulate('/p2p-circuit');
        }));
        this.safeDispatchEvent('listening', {});
    }
    getAddrs() {
        return [...this.listeningAddrs.values()].flat();
    }
    async close() {
    }
    #removeRelayPeer(peerId) {
        const had = this.listeningAddrs.has(peerId);
        log('relay peer removed %p - had reservation', peerId, had);
        this.listeningAddrs.delete(peerId);
        if (had) {
            // Announce listen addresses change
            this.safeDispatchEvent('close', {});
        }
    }
}
export function createListener(options) {
    return new CircuitRelayTransportListener(options);
}
//# sourceMappingURL=listener.js.map