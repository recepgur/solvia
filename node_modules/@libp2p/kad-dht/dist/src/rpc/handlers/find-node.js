import { protocols } from '@multiformats/multiaddr';
import { equals as uint8ArrayEquals } from 'uint8arrays';
import { Message } from '../../message/index.js';
import { removePrivateAddresses, removePublicAddresses } from '../../utils.js';
export class FindNodeHandler {
    peerRouting;
    lan;
    peerId;
    addressManager;
    log;
    constructor(components, init) {
        const { peerRouting, lan } = init;
        this.log = components.logger.forComponent('libp2p:kad-dht:rpc:handlers:find-node');
        this.peerId = components.peerId;
        this.addressManager = components.addressManager;
        this.peerRouting = peerRouting;
        this.lan = Boolean(lan);
    }
    /**
     * Process `FindNode` DHT messages
     */
    async handle(peerId, msg) {
        this.log('incoming request from %p for peers closer to %b', peerId, msg.key);
        let closer = [];
        if (uint8ArrayEquals(this.peerId.toBytes(), msg.key)) {
            closer = [{
                    id: this.peerId,
                    multiaddrs: this.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code))
                }];
        }
        else {
            closer = await this.peerRouting.getCloserPeersOffline(msg.key, peerId);
        }
        closer = closer
            .map(this.lan ? removePublicAddresses : removePrivateAddresses)
            .filter(({ multiaddrs }) => multiaddrs.length);
        const response = new Message(msg.type, new Uint8Array(0), msg.clusterLevel);
        if (closer.length > 0) {
            response.closerPeers = closer;
        }
        else {
            this.log('could not find any peers closer to %b than %p', msg.key, peerId);
        }
        return response;
    }
}
//# sourceMappingURL=find-node.js.map