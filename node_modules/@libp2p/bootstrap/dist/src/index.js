import { EventEmitter } from '@libp2p/interface/events';
import { peerDiscovery } from '@libp2p/interface/peer-discovery';
import { logger } from '@libp2p/logger';
import { peerIdFromString } from '@libp2p/peer-id';
import { P2P } from '@multiformats/mafmt';
import { multiaddr } from '@multiformats/multiaddr';
const log = logger('libp2p:bootstrap');
const DEFAULT_BOOTSTRAP_TAG_NAME = 'bootstrap';
const DEFAULT_BOOTSTRAP_TAG_VALUE = 50;
const DEFAULT_BOOTSTRAP_TAG_TTL = 120000;
const DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1000;
/**
 * Emits 'peer' events on a regular interval for each peer in the provided list.
 */
class Bootstrap extends EventEmitter {
    static tag = 'bootstrap';
    timer;
    list;
    timeout;
    components;
    _init;
    constructor(components, options = { list: [] }) {
        if (options.list == null || options.list.length === 0) {
            throw new Error('Bootstrap requires a list of peer addresses');
        }
        super();
        this.components = components;
        this.timeout = options.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT;
        this.list = [];
        for (const candidate of options.list) {
            if (!P2P.matches(candidate)) {
                log.error('Invalid multiaddr');
                continue;
            }
            const ma = multiaddr(candidate);
            const peerIdStr = ma.getPeerId();
            if (peerIdStr == null) {
                log.error('Invalid bootstrap multiaddr without peer id');
                continue;
            }
            const peerData = {
                id: peerIdFromString(peerIdStr),
                multiaddrs: [ma],
                protocols: []
            };
            this.list.push(peerData);
        }
        this._init = options;
    }
    [peerDiscovery] = this;
    [Symbol.toStringTag] = '@libp2p/bootstrap';
    isStarted() {
        return Boolean(this.timer);
    }
    /**
     * Start emitting events
     */
    start() {
        if (this.isStarted()) {
            return;
        }
        log('Starting bootstrap node discovery, discovering peers after %s ms', this.timeout);
        this.timer = setTimeout(() => {
            void this._discoverBootstrapPeers()
                .catch(err => {
                log.error(err);
            });
        }, this.timeout);
    }
    /**
     * Emit each address in the list as a PeerInfo
     */
    async _discoverBootstrapPeers() {
        if (this.timer == null) {
            return;
        }
        for (const peerData of this.list) {
            await this.components.peerStore.merge(peerData.id, {
                tags: {
                    [this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME]: {
                        value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,
                        ttl: this._init.tagTTL ?? DEFAULT_BOOTSTRAP_TAG_TTL
                    }
                }
            });
            // check we are still running
            if (this.timer == null) {
                return;
            }
            this.safeDispatchEvent('peer', { detail: peerData });
        }
    }
    /**
     * Stop emitting events
     */
    stop() {
        if (this.timer != null) {
            clearTimeout(this.timer);
        }
        this.timer = undefined;
    }
}
export function bootstrap(init) {
    return (components) => new Bootstrap(components, init);
}
//# sourceMappingURL=index.js.map