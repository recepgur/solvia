import torch
from transformers import GPT2LMHeadModel, GPT2Tokenizer
import logging
from typing import Dict, Optional

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ExploitGenerator:
    def __init__(self, model_path: str = "EleutherAI/gpt-neo-125M"):
        self.model_path = model_path
        self.tokenizer = self._load_tokenizer()
        self.model = self._load_model()
        self.model.eval()
        
    def _load_tokenizer(self) -> GPT2Tokenizer:
        """Load the GPT tokenizer."""
        logger.info(f"Loading tokenizer from {self.model_path}")
        return GPT2Tokenizer.from_pretrained(self.model_path)
        
    def _load_model(self) -> GPT2LMHeadModel:
        """Load the GPT model."""
        logger.info(f"Loading model from {self.model_path}")
        return GPT2LMHeadModel.from_pretrained(self.model_path)
        
    def generate_exploit(self, vulnerability_info: str, 
                        context: Optional[Dict] = None,
                        max_length: int = 1024) -> str:
        """Generate an exploit based on vulnerability information."""
        try:
            # Prepare input text
            input_text = f"Vulnerability: {vulnerability_info}\n"
            if context:
                input_text += f"Context: {str(context)}\n"
            input_text += "Exploit:\n"
            
            # Tokenize input
            inputs = self.tokenizer(input_text, return_tensors="pt")
            
            # Generate exploit
            with torch.no_grad():
                outputs = self.model.generate(
                    inputs["input_ids"],
                    max_length=max_length,
                    num_return_sequences=1,
                    no_repeat_ngram_size=2,
                    temperature=0.7
                )
                
            # Decode and return generated text
            generated_text = self.tokenizer.decode(outputs[0], skip_special_tokens=True)
            exploit_code = generated_text[len(input_text):]
            
            return exploit_code.strip()
            
        except Exception as e:
            logger.error(f"Error generating exploit: {e}")
            return ""

if __name__ == "__main__":
    generator = ExploitGenerator()
    vulnerability = "SQL injection in login form"
    exploit = generator.generate_exploit(vulnerability)
    print(f"Generated exploit:\n{exploit}")
